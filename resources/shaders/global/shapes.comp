#version 450
#extension GL_ARB_compute_shader : enable
#extension GL_ARB_separate_shader_objects : enable

//
// Uniform
//

layout(set = 0, binding = 0) uniform ShaderUniforms {
    vec2 pixelSize;
    vec2 _padding;
} uniforms;

//
// Input
//

struct ShapeProperties {
    vec4 borderColor;
    vec4 params; // x=type, y=borderWidth, z=cornerRadius, w=unused
};

layout(std430, set = 0, binding = 1) readonly buffer PropertiesBuffer {
    ShapeProperties properties[];
};

layout(std430, set = 0, binding = 2) readonly buffer FillColorsBuffer {
    vec4 fillColors[];
};

layout(std430, set = 0, binding = 3) readonly buffer RotationsBuffer {
    float rotationsDeg[];
};

layout(std430, set = 0, binding = 4) readonly buffer SizesBuffer {
    vec2 sizes[];
};

layout(std430, set = 0, binding = 5) readonly buffer PositionsBuffer {
    vec2 positions[];
};

//
// Output
//

struct InstanceData {
    mat4 transform;
    vec4 fillColor;
    vec4 borderColor;
    vec4 shapeParams; // x=type, y=borderWidth, z=cornerRadius, w=unused
};

layout(std430, set = 0, binding = 6) buffer InstanceDataBuffer {
    InstanceData instances[];
};

//
// Helper Functions
//

mat4 createRotationMatrix(float angleDeg) {
    float angleRad = radians(angleDeg);
    float c = cos(angleRad);
    float s = sin(angleRad);

    return mat4(
        c,  -s,  0.0, 0.0,
        s,   c,  0.0, 0.0,
        0.0, 0.0, 1.0, 0.0,
        0.0, 0.0, 0.0, 1.0
    );
}

//
// Main
//

void main() {
    uint i = gl_GlobalInvocationID.x;

    // Get consolidated properties
    ShapeProperties props = properties[i];
    vec4 borderColor = props.borderColor;
    vec4 shapeParams = props.params;

    // Get instance data
    vec2 position = positions[i];
    vec2 size = sizes[i];
    float rotationDeg = rotationsDeg[i];
    vec4 fillColor = fillColors[i];

    // Build transform matrix - matrices are column-major in GLSL
    mat4 transform = mat4(1.0);

    // Create transformation matrices
    mat4 translation = mat4(
        1.0, 0.0, 0.0, 0.0,
        0.0, 1.0, 0.0, 0.0,
        0.0, 0.0, 1.0, 0.0,
        position.x, position.y, 0.0, 1.0
    );

    mat4 pixelScale = mat4(
        uniforms.pixelSize.x, 0.0, 0.0, 0.0,
        0.0, uniforms.pixelSize.y, 0.0, 0.0,
        0.0, 0.0, 1.0, 0.0,
        0.0, 0.0, 0.0, 1.0
    );

    mat4 scale = mat4(
        size.x, 0.0, 0.0, 0.0,
        0.0, size.y, 0.0, 0.0,
        0.0, 0.0, 1.0, 0.0,
        0.0, 0.0, 0.0, 1.0
    );

    mat4 rotation = createRotationMatrix(rotationDeg);

    // Apply transformations: T * R * S * P (right-to-left)
    // This applies: pixelScale, then scale, then rotation, then translation
    transform = translation * rotation * scale * pixelScale;

    // Write output
    instances[i].transform = transform;
    instances[i].fillColor = fillColor;
    instances[i].borderColor = borderColor;
    instances[i].shapeParams = shapeParams;
}
